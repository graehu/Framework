#include "gSdl.h"
#include <cassert>

int gSdl::init()
{
  m_windowSurface = SDL_GetVideoSurface();
  SDL_SetColorKey(m_windowSurface, SDL_SRCCOLORKEY | SDL_RLEACCEL, SDL_MapRGB(m_windowSurface->format, 0xff, 0x00, 0xff));
  return 0;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int gSdl::update()
{
  return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//this is how an image is blited to a surface
void gSdl::visit(sprite* _sprite) //rendering a sprite :)
{
  //you can use image->w to get the width of the image.
	if(m_images.find(_sprite->m_fileName) == m_images.end())
		loadImage(_sprite->m_fileName);

  SDL_Surface* image = SDL_DisplayFormat(&m_images[_sprite->m_fileName]);
  SDL_Rect source, destination;

  //image space
  source.x = 0;
  source.y = 0;
  source.w = image->w; //for now this doesn't take into account the cropping WHATEVES.
  source.h = image->h;

  //screen space
  destination.x = _sprite->m_x;
  destination.y = _sprite->m_y;
  destination.w = image->w;
  destination.h = image->h;

  //image successfully blitted to the screen surface. flip to render.
  SDL_BlitSurface(image, &source, m_windowSurface, &destination);
  SDL_FreeSurface(image);
  //SDL_UpdateRects(m_windowSurface, 1, &destination);
}



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int gSdl::loadImage(char* _fileName)
{

  SDL_Surface* l_loadedImage;
  l_loadedImage = IMG_Load(_fileName);

  if (l_loadedImage == NULL)
    {
      printf("Unable to load bitmap: %s\n\n", SDL_GetError());
	  assert(false);
      return 0;
    }
  else
  {
	  SDL_Surface* l_optimisedImage = SDL_DisplayFormat(l_loadedImage);
	  SDL_FreeSurface(l_loadedImage);
	  if(l_optimisedImage == NULL)
	  {
	      printf("Unable to load bitmap: %s\n\n", SDL_GetError());
		  assert(false);
	      return 0;
	  }
	  else
	  {
		  Uint32 colourkey = SDL_MapRGB(l_optimisedImage->format, 0xFF, 0, 0xFF );
		  SDL_SetColorKey(l_optimisedImage, SDL_SRCCOLORKEY, colourkey);
		  m_images[_fileName] = *l_optimisedImage;
	  }
  }
  return m_images.size() - 1;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


int gSdl::render()
{
  SDL_Flip(m_windowSurface);
  SDL_FillRect(m_windowSurface, 0, SDL_MapRGB(m_windowSurface->format, 64, 64, 64));
  return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




int gSdl::shutdown()
{
  //delete any and all resources before ending the program with this function

  //might want to think about a way to delete all the gObjects that could have been created by this point.
  //not sure if its actually nessisary to be honest

  return 0;

} //shutsdown the graphics engine, probably called in the destructor or something


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

iRenderVisitor* gSdl::getRenderer()
{
  return (iRenderVisitor*)this;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


graphics* graphics::graphicsFactory()
{
  return (graphics*)new gSdl;
}



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Un used fuzzy logic graphs
/*void gSdl::visit(Graph* _graph)
{
	//stuffs
	unsigned int i = 0;
	Uint32 c_white = SDL_MapRGB(m_windowSurface->format, 255,255,255);
	Shape* l_shape = _graph->getShape(i);
	while(l_shape != NULL)
	{
		Shape::type l_type = l_shape->getType();
		switch(l_type)
		{
		case Shape::e_base:
			break;
		case Shape::e_triangle:
			{
			Triangle* l_triangle = (Triangle*)l_shape;
			Draw_Line(m_windowSurface,
				(l_triangle->getLeftBound()*_graph->m_scale)+_graph->m_x,  
				_graph->m_y, 
				(l_triangle->getCenterPoint()*_graph->m_scale)+_graph->m_x,
				(-1*_graph->m_scale)+_graph->m_y,
				c_white);
			Draw_Line(m_windowSurface,
				(l_triangle->getCenterPoint()*_graph->m_scale)+_graph->m_x,
				(-1*_graph->m_scale)+_graph->m_y,
				(l_triangle->getRightBound()*_graph->m_scale)+_graph->m_x,
				_graph->m_y,
				c_white);
			}
			break;
		case Shape::e_plateau:
			{
				Plateau* l_plateau = (Plateau*)l_shape;
				Draw_Line(m_windowSurface,
				(l_plateau->getBottom()*_graph->m_scale)+_graph->m_x,
				_graph->m_y,
				(l_plateau->getTop()*_graph->m_scale)+_graph->m_x,
				(-1*_graph->m_scale)+_graph->m_y,
				c_white);
				if(l_plateau->isLeftPlateau())
					Draw_Line(m_windowSurface,
					(l_plateau->getTop()*_graph->m_scale)+_graph->m_x,
					(-1*_graph->m_scale)+_graph->m_y,
					((l_plateau->getTop()-1)*_graph->m_scale)+_graph->m_x,
					(-1*_graph->m_scale)+_graph->m_y,
					c_white);
				else
				Draw_Line(m_windowSurface,
					(l_plateau->getTop()*_graph->m_scale)+_graph->m_x,
					(-1*_graph->m_scale)+_graph->m_y,
					((l_plateau->getTop()+1)*_graph->m_scale)+_graph->m_x,
					(-1*_graph->m_scale)+_graph->m_y,
					c_white);
			}
			break;
		}
		i++;
		l_shape = _graph->getShape(i);
	}
}*/