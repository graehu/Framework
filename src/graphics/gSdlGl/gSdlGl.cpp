#include "gSdlGl.h"
int gSdlGl::init()
{
  m_windowSurface = SDL_GetVideoSurface();
  SDL_SetColorKey(m_windowSurface, SDL_SRCCOLORKEY | SDL_RLEACCEL, SDL_MapRGB(m_windowSurface->format, 0xff, 0x00, 0xff));
  return 0;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int gSdlGl::update()
{
  return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//this is how a an image is blited to a surface
void gSdlGl::visit(sprite* _sprite) //rendering a sprite :)
{
  //you can use image->w to get the width of the image.
  SDL_Surface* image = SDL_DisplayFormat(&m_images[_sprite->m_imageID]);
  SDL_Rect source, destination;

  //image space
  source.x = 0;
  source.y = 0;
  source.w = image->w; //for now this doesn't take into account the cropping WHATEVES.
  source.h = image->h;

  //screen space
  destination.x = _sprite->m_x;
  destination.y = _sprite->m_y;
  destination.w = image->w;
  destination.h = image->h;

  //image successfully blitted to the screen surface. flip to render.
  SDL_BlitSurface(image, &source, m_windowSurface, &destination);
  SDL_FreeSurface(image);
  //SDL_UpdateRects(m_windowSurface, 1, &destination);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


int gSdlGl::loadImage(char* _fileName)
{

  SDL_Surface* l_loadedImage;
  l_loadedImage = IMG_Load(_fileName);

  if (l_loadedImage == NULL)
    {
      printf("Unable to load bitmap: %s\n", SDL_GetError());
      return 0;
    }
  else
  {
	  SDL_Surface* l_optimisedImage = SDL_DisplayFormat(l_loadedImage);
	  SDL_FreeSurface(l_loadedImage);
	  if(l_optimisedImage == NULL)
	  {
	      printf("Unable to load bitmap: %s\n", SDL_GetError());
	      return 0;
	  }
	  else
	  {
		  Uint32 colourkey = SDL_MapRGB(l_optimisedImage->format, 0xFF, 0, 0xFF );
		  SDL_SetColorKey(l_optimisedImage, SDL_SRCCOLORKEY, colourkey);
		  m_images.push_back(*l_optimisedImage);
	  }
  }
  return m_images.size() - 1;
}




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


int gSdlGl::unloadImage(int _imageID){return 0;}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




int gSdlGl::render()
{

	glTranslatef(-1.5f,0.0f,-6.0f);           
	glBegin(GL_TRIANGLES);                      // Drawing Using Triangles
    glVertex3f( 0.0f, 1.0f, 0.0f);              // Top
    glVertex3f(-1.0f,-1.0f, 0.0f);              // Bottom Left
    glVertex3f( 1.0f,-1.0f, 0.0f);              // Bottom Right
glEnd();     
glTranslatef(3.0f,0.0f,0.0f);       
  glBegin(GL_QUADS);                      // Draw A Quad
        glVertex3f(-1.0f, 1.0f, 0.0f);              // Top Left
        glVertex3f( 1.0f, 1.0f, 0.0f);              // Top Right
        glVertex3f( 1.0f,-1.0f, 0.0f);              // Bottom Right
        glVertex3f(-1.0f,-1.0f, 0.0f);              // Bottom Left
    glEnd();                            // Done Drawing The Quad*/


  //SDL_Flip(m_windowSurface);
  SDL_GL_SwapBuffers();
  SDL_FillRect(m_windowSurface, 0, SDL_MapRGB(m_windowSurface->format, 0, 0, 0));

  return 0;

}




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




int gSdlGl::shutdown()
{
  //delete any and all resources before ending the program with this function

  //might want to think about a way to delete all the gObjects that could have been created by this point.
  //not sure if its actually nessisary to be honest

  return 0;

} //shutsdown the graphics engine, probably called in the destructor or something


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

iRenderVisitor* gSdlGl::getRenderer()
{
  return (iRenderVisitor*)this;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////








graphics* graphics::graphicsFactory()
{
  return (graphics*)new gSdlGl;
}
